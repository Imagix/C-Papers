---
title: "std::at : Range-checked accesses to arbitrary containers"
document: P3404R1
date: today
audience: LEWG, SG9 (Ranges)
author:
  - name: Andre Kostur
    email: <andre@kostur.net>
toc: true
---

# Abstract

This proposal is to add a customization point object for `std::at()`
which will forward to containers which have a member function `at()`.
In addition this will also apply to arrays.

# Motivation 

Lately there has been a stronger push towards code safety, in particular
performing range-checked accesses to containers.  A number of existing
containers have both an `operator[]` for unchecked accesses, as well as
an `at()` member function for range-checked accesses which may throw an
`std::out_of_range` exception.  It would be useful to be able to have
an `at()` for user-declared types which may not have provided their own
as well as having range-checked accesses to arrays.  This facilitates
generic programming with containers in the same manner that `std::begin()`
does.

# Revision History

## R1

- Added references to mdspan::at
- Incorporating feedback from the Wroclaw 2024 meeting

## R0

Initial revision.

# Design

Define a customization point object `std::at()` which may be used
instead of calling a member-function `at()`.

Since C++23 `operator[]` can take any number of subscripts, it is reasonable
to anticipate that user-defined classes will start to have a member function
`at()` taking multiple subscripts.  `std::mdspan` and `std::mdarray` [@P1684R5]
do support multple subscripts.  `std::mdarray` does not yet have an `at()`
proposed, but `std::mdspan` does have one currently proposed in [@P3383R0].

There are three cases that this proposal needs to consider:

1. Containers which have a member-function `at()`.  `std::at()` will
   call the member function, forwarding all of the additional arguments.
1. Arrays cannot have member functions.  `std::at()` will test the
   subscript to verify that it is in range, and will throw `std::out_of_range`
   when the range is violated.
1. User declared free-function `at()`, presumably in the same namespace
   as the container so as to take advantage of ADL to choose this function
   over the templated function that will be provided in the standard
   library.

As `at()` functions use exceptions as the error reporting mechanism, this is
not applicable to freestanding and should be explicitly marked as
freestanding-deleted, just as `std::span::at()` is.

A fourth case was discussed about synthesizing an `at()` for ranges that have
a `size()` method and an indexing operator.  However it cannot be assumed that
the index into that class is necessarily 0-based, which would make any
synthesized range-check misbehave silently. 

# Feature Test Macro

```
#define __cpp_lib_at xxxxxxL
```

# Reference implementation
This is only for demonstration purposes is not
intended to dictate implementation.

```cpp
#ifndef STDAT_H
#define STDAT_H

#include <stdexcept>

namespace std
{
    namespace __detail
    {
        // define at for arrays
        template <class T, size_t N>
        constexpr T & at(T (&a)[N], size_t idx)
        {
            if (N <= idx)
            {
                throw std::out_of_range("generic at");
            }

            return a[idx];
        }

        // Define at for containers
        // (trailing return type needed for SFINAE)
        template <class _RangeLike, typename... _Idxs>
        constexpr auto at(_RangeLike &&rng, _Idxs &&... idxs)
            -> decltype(std::forward<_RangeLike>(rng).at(std::forward<_Idxs>(idxs)...))
        {
            return std::forward<_RangeLike>(rng).at(std::forward<_Idxs>(idxs)...);
        }

        struct __at_fn
        {
            template <class R, typename... _Idxs>
            constexpr auto operator()(R &&rng, _Idxs &&... idxs) const
                -> decltype(at(std::forward<R>(rng), std::forward<_Idxs>(idxs)...))
            {
                return at(std::forward<R>(rng), std::forward<_Idxs>(idxs)...);
            }
        };
    }

    // To avoid ODR violations:
    template <class T>
    constexpr T __static_const{};

    // std::at is a global function object
    namespace
    {
        constexpr auto const &at =
            __static_const<__detail::__at_fn>;
    }
}

#endif // STDAT_H
```

## Case 1: Containers with `at()` member function(s)

```cpp
template <class _RangeLike, typename... _Idxs>
constexpr auto at(_RangeLike &&rng, _Idxs &&... idxs)
    -> decltype(std::forward<_RangeLike>(rng).at(std::forward<_Idxs>(idxs)...))
{
    return std::forward<_RangeLike>(rng).at(std::forward<_Idxs>(idxs)...);
}
```

## Case 2: Arrays

```cpp
template <class T, size_t N>
constexpr T & at(T (&a)[N], size_t idx)
{
    if (N <= idx)
    {
        throw std::out_of_range("generic at");
    }

    return a[idx];
}
```

## Case 3: Custom overload

```cpp
template <class R, typename... _Idxs>
constexpr auto operator()(R &&rng, _Idxs &&... idxs) const
    -> decltype(at(std::forward<R>(rng), std::forward<_Idxs>(idxs)...))
{
    return at(std::forward<R>(rng), std::forward<_Idxs>(idxs)...);
}
```

# Proposed Wording

# Acknowledgements

Thank-you to Herb Sutter for the initial inspiration.
